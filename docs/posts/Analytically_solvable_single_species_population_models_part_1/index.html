<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Veli-Pekka Uusluoto">
<meta name="dcterms.date" content="2025-11-16">

<title>Analytically solvable single species population models part 1 – Math blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-a26421d82f52bf2d5e6476a19b1921eb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script type="text/javascript">
  window.MathJax = {
    loader: {
      load: ['[tex]/upgreek']
    },
    tex: {
      packages: {
        '[+]': ['upgreek']
      },
    }
  };
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Math blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Analytically solvable single species population models part 1</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Mathematical biology</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Veli-Pekka Uusluoto </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 16, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="hidden">

</div>
<p>Mathematical biology is one of those topics that I want to learn so I will be writing about it. In this post, I will discuss shortly single species continuous population models that can be analytically solved. They may not have practical use cases nowadays anymore, but knowing what can be solved analytically is mathematically interesting and instructive topic.</p>
<p>(There may be more mistakes and typos in this post since I have written this with little time and using my previous notes on the topic. I wanted to adjust my posting schedule to one post each Sunday and doing things this way I can move my posting schedule. I have checked that differential equations and solutions of the models are at least correct)</p>
<p>The main mathematical tool that we use today is the following theorem.</p>
<p><strong>Theorem 1:</strong> Let <span class="math inline">\(f: \mathbb{R}\to \mathbb{R}\)</span> be a continuous function. The <span class="math inline">\(C^1\)</span>-solutions (solutions that have continuous derivative) of differential equation <span class="math inline">\(\frac{d}{dt} y(t) = f(t)\)</span> are in form of <span class="math inline">\(y(t) = \int_{t_0}^t f(s) \, ds + C\)</span> where <span class="math inline">\(C\)</span> is a number in <span class="math inline">\(\mathbb{R}\)</span>.</p>
<p><strong>Proof:</strong> By the Fundamental Theorem of Calculus we know that for the function <span class="math inline">\(F(t) = \int_{t_0}^t f(s) \, ds\)</span> we have <span class="math inline">\(\frac{d}{dt} F(t) = f(t)\)</span>. This shows one part of the theorem.</p>
<p>Assume that there are two functions <span class="math inline">\(y_1(t), y_2(t)\)</span> that satisfy the differential equation <span class="math inline">\(\frac{d}{dt} y(t) = f(t)\)</span>. We can calculate that <span class="math inline">\(\frac{d}{dt}(y_1(t)- y_2(t)) = f(t) - f(t) = 0\)</span>. So we are studying the solutions of <span class="math inline">\(\frac{d}{dt} u(t) = 0\)</span>. Only <span class="math inline">\(C^1\)</span>-solutions of that equations are the constant functions <span class="math inline">\(u(t) = C\)</span> where <span class="math inline">\(C \in \mathbb{R}\)</span>. This can be seen by assuming the opposite and then using the mean value theorem to find a point where <span class="math inline">\(\frac{d}{dt}u(t) \neq 0\)</span>. So we can conclude that every <span class="math inline">\(C^1\)</span>-solution is form of <span class="math inline">\(y(t) = \int_{t_0}^t f(s) \, ds + C\)</span> where <span class="math inline">\(C \in \mathbb{R}\)</span>.</p>
<section id="population-models" class="level1">
<h1>Population models</h1>
<p>In general, population change of some species in certain area will be determined by following rule</p>
<p><span class="math display">\[    \mathrm{population ~ change} = \mathrm{births} - \mathrm{deaths} + \mathrm{migration}. \]</span></p>
<p>This is the only way that population size can change. We can model populations with continuous or discrete functions or combination of those. We start by studying continuous population models that do not have a delay factors, i.e.&nbsp;population change is determined by population at current time.</p>
</section>
<section id="malthusian-population-growth-model" class="level1">
<h1>Malthusian population growth model</h1>
<p>The simplest model assumes that the births and the deaths of population is linearly dependent on the population <span class="math inline">\(P(t)\)</span>, so <span class="math inline">\(\mathrm{births} = b \cdot P(t)\)</span> and deaths <span class="math inline">\(\mathrm{deaths} = d \cdot P(t)\)</span>. Thus the population dynamics is given by</p>
<p><span class="math display">\[\frac{d}{dt}P(t) = (b-d)P(t), ~~ P(0)=P_0\]</span></p>
<p>This can be solved the following way (we will denote <span class="math inline">\(\frac{d}{dt} P(t)\)</span> by <span class="math inline">\(P'(t)\)</span> to make things easier to write.):</p>
<span class="math display">\[\begin{equation}
\begin{split}
    &amp; P'(t) = (b-d) P(t) \\
\iff &amp; \frac{P'(t)}{P(t)} = (b-d) \\
\iff &amp; \frac{d}{dt}(\ln(P(t))) = (b-d) \\
\iff &amp; \ln(P(t)) = (b-d)t + C \\
\iff &amp; P(t) = e^C e^{(b-d)t} = A e^{(b-d)t}
\end{split}
\end{equation}\]</span>
<p>where we have used the Theorem 1. The constant <span class="math inline">\(A\)</span> can be determined by setting <span class="math inline">\(t= 0\)</span> to <span class="math inline">\(P(t)= A e^{(b-d)}t\)</span> and thus obtaining <span class="math inline">\(A = P_0\)</span>.</p>
<p>The population that follows Malthusian growth model either growths indefinitely and rapidly or decreases to 0 quickly. The infinite growth isn’t very realistic since resources would run out. In the logistic model, there is a way to model the environmental capacity.</p>
</section>
<section id="logistic-growth-model" class="level1">
<h1>Logistic growth model</h1>
<p>The logistic growth model is the following dynamical law</p>
<span class="math display">\[\begin{equation}
    \label{continuous_logistic_model}
    N'(t) = r N(t) (1-\frac{N(t)}{K}), ~~ N(0) = N_0
\end{equation}\]</span>
<p>where <span class="math inline">\(K\)</span> is called environmental capacity of the system and the <span class="math inline">\(r\)</span> is a constant that determines growth rate in Malthusian sense. At small population sizes the model will behave like Malthusian growth model, but when the population grows the factor <span class="math inline">\((1- \frac{N(t)}{K})\)</span> will make the growth slower and slower. If the population start beyond environmental capacity, the factor <span class="math inline">\((1- \frac{N(t)}{K})\)</span> will be negative and the population will decrease. When population is at the environmental capacity <span class="math inline">\(P(t) = K\)</span> the population will be stable (and moreover, that point is an attractor of the system).</p>
<p>The solution of logistic model is the following</p>
<span class="math display">\[\begin{equation}
    \label{continuous_logistic_solution}
  N(t) = \frac{N_0 K e^{rt}}{K+ N_0 (e^{rt} -1)}.   
\end{equation}\]</span>
<p>Let’s show this and start by rewriting the differential equation as</p>
<span class="math display">\[\begin{equation}
    \frac{K N'(t)}{N(t)(K - N(t))} = r.
\end{equation}\]</span>
<p>If we can find a partial fraction decomposition in form of</p>
<span class="math display">\[\begin{equation}
    KN'(t)(\frac{A}{N(t)} + \frac{B}{K-N(t)})
\end{equation}\]</span>
<p>for the left hand side, we obtain something that we can integrate. By doing standard partial fraction calculations, we obtain that <span class="math inline">\(A=B=\frac{1}{K}\)</span>, so the equation takes the form</p>
<span class="math display">\[\begin{equation}
    \frac{N'(t)}{N(t)} + \frac{N'(t)}{K-N(t)} = r.
\end{equation}\]</span>
<p>We observe that this is equal to</p>
<span class="math display">\[\begin{equation}
    \frac{d}{dt}(\ln N(t) - \ln (K-N(t))) = r.
\end{equation}\]</span>
<p>By using the Theorem 1 and rules of logarithms, we get</p>
<p><span class="math display">\[ \ln (\frac{N(t)}{K-N(t)}) = rt + C \]</span> so with <span class="math inline">\(A = e^C\)</span></p>
<span class="math display">\[\begin{equation}
    \label{eq_for_A_logistic}
    \frac{N(t)}{K-N(t)} = A e^{rt}
\end{equation}\]</span>
<p>and thus</p>
<span class="math display">\[\begin{equation}
    N(t) = \frac{AK e^{rt}}{1+A e^{rt}}.
\end{equation}\]</span>
<p>This looks different from the claim, but when we use initial condition and the equation <span class="math inline">\(\frac{N(t)}{K-N(t)} = A e^{rt}\)</span> to solve A, we obtain</p>
<span class="math display">\[\begin{equation}
    N(t) = \frac{KN_0 e^{rt}}{(K-N_0) (1+ \frac{N_0}{K-N_0} e^{rt})} = \frac{KN_0 e^{rt}}{(K - N_0 + N_0 e^{rt})} =  \frac{KN_0 e^{rt}}{K + N_0 (e^{rt} - 1)}
\end{equation}\]</span>
<p>which is same as what we claimed.</p>
</section>
<section id="gompertz-growth-model" class="level1">
<h1>Gompertz growth model</h1>
<p>There are an another way to modify the logistic population model. In the logistic model, the damping factor, <span class="math inline">\((1-N/K)\)</span> is linearly dependent on <span class="math inline">\(N(t)\)</span>. In Gompertz model, the damping factor is chosen to be logarithmically dependent <span class="math inline">\(\ln(\frac{K}{N(t)}) = \ln(K) - \ln(N(t))\)</span>. The model will follow exponential growth longer than logistic model. The evolution equation of the Gompertz model is the following</p>
<span class="math display">\[\begin{equation}
    N'(t) = r N(t)\ln(\frac{K}{N(t)}) , ~~ N(0) = N_0.
\end{equation}\]</span>
<p>This can be solved analytically. So let’s do that. Let’s us start by writing equation as follows</p>
<span class="math display">\[\begin{equation}
    \frac{\frac{N'(t)}{N(t)}}{ \ln(K) - \ln (N(t))} =r.
\end{equation}\]</span>
<p>This can be seen as a following derivative</p>
<span class="math display">\[\begin{equation}
    -\frac{d}{dt}\ln (\ln (K) - \ln (N(t)))) = r.
\end{equation}\]</span>
<p>In same way as previously, we apply the Theorem 1 to get</p>
<span class="math display">\[\begin{equation}
    \ln (\ln(K) - \ln(N(t))) = -rt + C.
\end{equation}\]</span>
<p>When we apply exponential function to this and move terms, we get</p>
<span class="math display">\[\begin{equation}
    \label{Gompertz_D}
    \ln(N(t)) = \ln(K) - e^{-rt + C}
\end{equation}\]</span>
<p>and thus</p>
<span class="math display">\[\begin{equation}
    N(t) = K e^{- e^Ce^{-rt}}.
\end{equation}\]</span>
<p>The <span class="math inline">\(e^C\)</span> can be calculated using initial value and using the equation <span class="math inline">\(\ln(N(t)) = \ln(K) - e^{-rt + C}\)</span> and obtaining <span class="math inline">\(e^C = \ln(\frac{K}{N_0})\)</span>. So the solution is</p>
<span class="math display">\[\begin{equation}
    N(t) = K e^{-\ln(\frac{K}{N_0})e^{-rt}}.
\end{equation}\]</span>
<p>This model converges very quickly to the environmental capacity level.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/vpumath\.github\.io\/blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>