<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Veli-Pekka Uusluoto">
<meta name="dcterms.date" content="2025-11-23">

<title>Pearl removal process problem – Mathematical methods and models blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-a26421d82f52bf2d5e6476a19b1921eb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script type="text/javascript">
  window.MathJax = {
    loader: {
      load: ['[tex]/upgreek']
    },
    tex: {
      packages: {
        '[+]': ['upgreek']
      },
    }
  };
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Mathematical methods and models blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Pearl removal process problem</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Problem solving</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Veli-Pekka Uusluoto </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 23, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="hidden">

</div>
<p>One of my friends told me about following problem: Let’s study the following pearl removal process: There are <span class="math inline">\(N\)</span> pearls that forms a circle. Every pearl is numbered <span class="math inline">\(1,2,\dots, N\)</span> (given a tag) starting from some pearl. Starting from first pearl remove the next pearl. Go to the next pearl that isn’t removed and remove the pearl after that. Repeat this process until there is only one pearl left.</p>
<p><strong>Question:</strong> If there are <span class="math inline">\(N\)</span> pearls and the above removal process is applied, what pearl is the last one remaining (what is its tag)?</p>
<p>Here is how I solved that problem. The solution technique came into my mind from times when I learned about Fast Fourier Transforms and Cooley-Tukey algorithm.</p>
<p>We can study this process in rounds: At start of the process we have list of pearls <span class="math inline">\(L_0 = (1,2,3,\dots,N)\)</span>. After each round, we can give a pearl a new tag and we get a new starting list. The list <span class="math inline">\(L_k = (1,2,3,\dots,N_k)\)</span> means the numbering of the pearls after <span class="math inline">\(k\)</span> laps. At each round, the even numbered pearls are removed. Furthermore, if the number of pearls is odd, the first pearl is removed as well. In even case, the first pearl continues to the next list and start the process again.</p>
<p>We can write odd numbers as <span class="math inline">\(2k-1\)</span> for some <span class="math inline">\(k\)</span> (we have used minus sign instead of plus sign to get <span class="math inline">\(k=1\)</span> to match with <span class="math inline">\(1\)</span>). In the case when there are even number of pearls, the pearl’s <span class="math inline">\(2k-1\)</span> new tag will be <span class="math inline">\(k\)</span> and to the other direction: The previous tag of pearl <span class="math inline">\(k\)</span> is <span class="math inline">\(2k-1\)</span>. In the odd case, the pearl’s <span class="math inline">\(2k-1\)</span> new tag is <span class="math inline">\(k-1\)</span> (the numbering is shifted by -1 since the first pearl is removed). The previous tag of pearl’s <span class="math inline">\(k\)</span> is <span class="math inline">\(2(k+1)-1 = 2k+1\)</span>. Let’s define two functions:</p>
<span class="math display">\[\begin{eqnarray}
    \label{bw_fn}
    e(k) &amp;= 2k-1 \\
    o(k) &amp;= 2k+1
\end{eqnarray}\]</span>
<p>We need these functions later. Now we can study the length of removal process.</p>
<p><strong>Lemma 1:</strong> Let’s write N in the binary</p>
<p><span class="math display">\[\begin{equation}
    N = \sum_{i=0}^{m} a_i 2^i
\end{equation}\]</span> where <span class="math inline">\(a_i \in \{0,1\}\)</span> and <span class="math inline">\(a_m=1\)</span>. The length of the removal process is <span class="math inline">\(m\)</span> rounds.</p>
<p><strong>Proof:</strong> Let <span class="math inline">\(N_k\)</span> denote the size of <span class="math inline">\(L_k\)</span>. In the case when <span class="math inline">\(N_k\)</span> is even, the <span class="math inline">\(L_{k+1}\)</span> has half as many elements, so we have <span class="math inline">\(N_{k+1} =\frac{N_k}{2}\)</span>. In odd case, let <span class="math inline">\(N_k = 2L +1\)</span>, we can divide the list into two parts <span class="math inline">\((1,2,3,\dots,2L)\)</span> and <span class="math inline">\((2L+1)\)</span>. We can see that in the first part <span class="math inline">\(L\)</span> pearls are removed and the last pearl removes the first pearl and so <span class="math inline">\(N_{k+1} = \frac{N_k-1}{2}\)</span>. In both cases, the <span class="math inline">\(N_{k+1}\)</span> is obtained by chopping off the first digit of <span class="math inline">\(N_k\)</span> written in binary. Thus we can see that the removal process takes <span class="math inline">\(m\)</span> rounds.</p>
<p>From that proof we can see that <span class="math inline">\(a_k\)</span> determines the parity of <span class="math inline">\(N_k\)</span> and we have <span class="math inline">\(N_k \equiv a_k  \mod 2\)</span>.</p>
<p>To the solve original number tag of last pearl, we can work backwardly. In the end, the pearl have the number tag <span class="math inline">\(1\)</span>. Using functions <span class="math inline">\(e(x)\)</span> and <span class="math inline">\(o(x)\)</span>, we can calculate the tag <span class="math inline">\(T_{k-1}\)</span> in the list <span class="math inline">\(L_{k-1}\)</span> when we know the tag <span class="math inline">\(T_k\)</span> in the list <span class="math inline">\(L_k\)</span>. If <span class="math inline">\(N_{k-1}\)</span> ( i.e.&nbsp;<span class="math inline">\(a_{k}\)</span>) is even, then</p>
<span class="math display">\[\begin{equation}
    T_{k-1} = e(T_k) = 2T_k -1
\end{equation}\]</span>
<p>and if <span class="math inline">\(N_{k-1}\)</span> ( i.e.&nbsp;<span class="math inline">\(a_{k-1}\)</span>) is odd, then</p>
<span class="math display">\[\begin{equation}
    T_{k-1} = o(T_k) = 2T_k +1
\end{equation} \]</span>
<p>This gives the answer to the problem. However we can find a exact formula for <span class="math inline">\(T_0\)</span>. To show this, we start by studying special cases. When <span class="math inline">\(T_k = 1\)</span>, we have <span class="math inline">\(e(T_k) = 1\)</span> and <span class="math inline">\(o(T_k) = 11_2\)</span> (written in binary). Now assume that <span class="math inline">\(T_k = \sum_{i=1}^{j} b_i 2^i + 1\)</span> for some <span class="math inline">\(j&gt;=1\)</span>. When <span class="math inline">\(a_{k-1} = 0\)</span> (<span class="math inline">\(N_{k-1}\)</span> is even), we have</p>
<span class="math display">\[\begin{equation}
    T_{k-1} = e(T_k) = 2(\sum_{i=1}^{j} b_i 2^i + 1) - 1 =  \sum_{i=1}^{j} b_i 2^{i+1} + 1.
\end{equation}\]</span>
<p>From this form we can deduce that when <span class="math inline">\(a_{k-1}=0\)</span> we have simply added a zero next between the first and the second digit of <span class="math inline">\(T_k\)</span> when written in binary.</p>
<p>When <span class="math inline">\(a_{k-1}\)</span> (<span class="math inline">\(N_{k-1}\)</span>) is odd, we can write the following</p>
<span class="math display">\[\begin{equation}
    T_{k-1} = o(T_k) = 2(\sum_{i=1}^{j} b_i 2^i + 1) +1 = \sum_{i=1}^{j} b_i 2^{i+1} + 2 + 1.
\end{equation}\]</span>
<p>So when <span class="math inline">\(a_{k-1}=1\)</span>, the function <span class="math inline">\(o(x)\)</span> adds a number one between the first and the second digit of <span class="math inline">\(T_k\)</span> when written in binary. Both functions behaves similarly, they add the <span class="math inline">\(a_{k-1}\)</span> between first and the second digit of <span class="math inline">\(T_k\)</span>.</p>
<p>Now we can discuss how we obtain <span class="math inline">\(T_0\)</span>. Recall that we denoted <span class="math inline">\(N = \sum_{i=0}^{m} a_i 2^i\)</span> When we work backwards, we notice that if <span class="math inline">\(a_{m-1}\ = 0\)</span> then <span class="math inline">\(T_{m-1} = T_m = 1\)</span>. Similarly for each zero before that until we bump into some <span class="math inline">\(a_s\)</span> which is <span class="math inline">\(1\)</span>. Formally we can define <span class="math inline">\(s\)</span> as <span class="math inline">\(\max \{ i ~ |~ a_i = 1, i &lt; m \}\)</span>, if there is not such <span class="math inline">\(s\)</span> then we obtain that <span class="math inline">\(T_0 = 1\)</span>. From above discussion and with knowledge that <span class="math inline">\(o(1) = 11_2\)</span>, we can deduce that we add the rest of the binary digits to the left side of the digit 1 starting from <span class="math inline">\(a_s\)</span>. All in all, we can deduce that</p>
<span class="math display">\[\begin{equation}
    T_0  = 2 \sum_{i=0}^{s} a_i 2^i + 1  
\end{equation}\]</span>
<p>where <span class="math inline">\(s = \max (\{ i ~|~ a_i = 1, i &lt; m \} \cup \{0\})\)</span>. This can be written also in the following form:</p>
<p><span class="math display">\[T_0 = 2 (\sum_{i=0}^{m} a_i 2^i - 2^m) +1\]</span></p>
<p>There are also other ways to solve this problem (at least one other method).</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/vpumath\.github\.io\/blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>